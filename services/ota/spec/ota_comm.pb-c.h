/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: ota_comm.proto */

#ifndef PROTOBUF_C_ota_5fcomm_2eproto__INCLUDED
#define PROTOBUF_C_ota_5fcomm_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _OtaKeyValdata OtaKeyValdata;
typedef struct _OtaMessagePoll OtaMessagePoll;
typedef struct _OtaMessagePollResp OtaMessagePollResp;
typedef struct _OtaMessagePollResp__OtaGmtime OtaMessagePollResp__OtaGmtime;
typedef struct _OtaMessageTsfrHook OtaMessageTsfrHook;
typedef struct _OtaMessageTsfr OtaMessageTsfr;
typedef struct _OtaMessageTsfrAck OtaMessageTsfrAck;
typedef struct _OtaMessageTsfrQuery OtaMessageTsfrQuery;
typedef struct _OtaMessage OtaMessage;


/* --- enums --- */

/*
 * status of the request
 */
typedef enum _OtaMessagePollResp__OtaPollStatus {
  OTA_MESSAGE_POLL_RESP__OTA_POLL_STATUS__OTA_POLL_STATUS_OK = 1,
  OTA_MESSAGE_POLL_RESP__OTA_POLL_STATUS__OTA_POLL_INVALID_DEVICE_ID = 2,
  OTA_MESSAGE_POLL_RESP__OTA_POLL_STATUS__OTA_POLL_STATUS_RESRVED = 255
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(OTA_MESSAGE_POLL_RESP__OTA_POLL_STATUS)
} OtaMessagePollResp__OtaPollStatus;
typedef enum _OtaMessagePollResp__OtaEncAlg {
  OTA_MESSAGE_POLL_RESP__OTA_ENC_ALG__OTA_ENC_ALG_AES_128 = 1,
  OTA_MESSAGE_POLL_RESP__OTA_ENC_ALG__OTA_ENC_ALG_AES_256 = 2,
  /*
   * set when status is invalid
   */
  OTA_MESSAGE_POLL_RESP__OTA_ENC_ALG__OTA_ENC_ALG_INVALID = 255
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(OTA_MESSAGE_POLL_RESP__OTA_ENC_ALG)
} OtaMessagePollResp__OtaEncAlg;
typedef enum _OtaMessagePollResp__OtaSignAlg {
  OTA_MESSAGE_POLL_RESP__OTA_SIGN_ALG__OTA_SIGN_ALG_ECC_256 = 1,
  OTA_MESSAGE_POLL_RESP__OTA_SIGN_ALG__OTA_SIGN_ALG_RSA_4096 = 2,
  /*
   * set when status is invalid
   */
  OTA_MESSAGE_POLL_RESP__OTA_SIGN_ALG__OTA_SIGN_ALG_INVALID = 255
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(OTA_MESSAGE_POLL_RESP__OTA_SIGN_ALG)
} OtaMessagePollResp__OtaSignAlg;
typedef enum _OtaMessage__OtaProtoTypes {
  OTA_MESSAGE__OTA_PROTO_TYPES__OTA_MESSAGE_POLL = 1,
  OTA_MESSAGE__OTA_PROTO_TYPES__OTA_MESSAGE_POLL_RESP = 2,
  OTA_MESSAGE__OTA_PROTO_TYPES__OTA_MESSAGE_TSFR_HOOK = 3,
  OTA_MESSAGE__OTA_PROTO_TYPES__OTA_MESSAGE_TSFR_QUERY = 4,
  OTA_MESSAGE__OTA_PROTO_TYPES__OTA_MESSAGE_TSFR = 5,
  OTA_MESSAGE__OTA_PROTO_TYPES__OTA_MESSAGE_TSFR_ACK = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(OTA_MESSAGE__OTA_PROTO_TYPES)
} OtaMessage__OtaProtoTypes;

/* --- messages --- */

struct  _OtaKeyValdata
{
  ProtobufCMessage base;
  char *key;
  char *val;
};
#define OTA_KEY_VALDATA__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ota_key_valdata__descriptor) \
    , NULL, NULL }


struct  _OtaMessagePoll
{
  ProtobufCMessage base;
  /*
   * major
   */
  uint32_t myversion_x;
  /*
   * minor
   */
  uint32_t myversion_y;
  /*
   * patch level
   */
  uint32_t myversion_z;
  /*
   * bug fix ?
   */
  uint32_t myversion_w;
  /*
   * id of this device (like a sha1)
   */
  ProtobufCBinaryData deviceid;
  /*
   * manufactured date time
   */
  char *mfgdate;
  /*
   * hwrevision
   */
  char *hwrev;
  /*
   * these two lines for a second partition
   */
  /*
   * current hdd storage used
   */
  double cur_disk_used;
  /*
   * free hdd storage available
   */
  double free_disk;
  /*
   * list of hardware capabilities
   */
  size_t n_hwcaps;
  OtaKeyValdata **hwcaps;
  /*
   * list of software caps (like software name - revision pairs)
   * if required to update only particular mdoule
   */
  size_t n_swcaps;
  OtaKeyValdata **swcaps;
};
#define OTA_MESSAGE_POLL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ota_message_poll__descriptor) \
    , 0, 0, 0, 0, {0,NULL}, NULL, NULL, 0, 0, 0,NULL, 0,NULL }


struct  _OtaMessagePollResp__OtaGmtime
{
  ProtobufCMessage base;
  uint32_t year;
  uint32_t month;
  uint32_t day;
  uint32_t hour;
  uint32_t min;
  uint32_t sec;
};
#define OTA_MESSAGE_POLL_RESP__OTA_GMTIME__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ota_message_poll_resp__ota_gmtime__descriptor) \
    , 0, 0, 0, 0, 0, 0 }


struct  _OtaMessagePollResp
{
  ProtobufCMessage base;
  /*
   * same device id that is sent in poll is used to identify the receiver
   */
  ProtobufCBinaryData deviceid;
  /*
   * unique id generated by the server when status is OK.. use this for every transaction
   */
  ProtobufCBinaryData ota_resp_hash;
  OtaMessagePollResp__OtaPollStatus status;
  /*
   *  set to 1 if update is there.. 0 otherwise
   */
  uint32_t update_available;
  /*
   * major
   */
  uint32_t newver_x;
  /*
   * minor
   */
  uint32_t newver_y;
  /*
   * patch level
   */
  uint32_t newver_z;
  /*
   * build generated
   */
  uint32_t newver_w;
  char *firmware_name;
  /*
   * when this firmware is created
   */
  OtaMessagePollResp__OtaGmtime *created_timestamp;
  /*
   * size of OTA update in bytes
   */
  double update_size_bytes;
  OtaMessagePollResp__OtaEncAlg enc_alg;
  OtaMessagePollResp__OtaSignAlg sign_alg;
};
#define OTA_MESSAGE_POLL_RESP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ota_message_poll_resp__descriptor) \
    , {0,NULL}, {0,NULL}, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0 }


/*
 * let the server know we are ready
 */
struct  _OtaMessageTsfrHook
{
  ProtobufCMessage base;
  ProtobufCBinaryData deviceid;
  ProtobufCBinaryData ota_resp_hash;
  /*
   * set to 1 and let the server expect an ACK for every 10 packets
   * if server does not see an ack for 30 packets it drops the message sending process and purges the hash that's created for the transaction
   * set to 0 for faster but may be lossy if device goes out of coverage.. this is only for the servre to optimise its load
   */
  uint32_t sends_ack;
  /*
   * 10 times 20 times..
   */
  uint32_t ack_repeat_rate;
  /*
   * transfer buffer size
   */
  uint32_t txbuf_size;
};
#define OTA_MESSAGE_TSFR_HOOK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ota_message_tsfr_hook__descriptor) \
    , {0,NULL}, {0,NULL}, 0, 0, 0 }


struct  _OtaMessageTsfr
{
  ProtobufCMessage base;
  ProtobufCBinaryData deviceid;
  ProtobufCBinaryData ota_resp_hash;
  /*
   *current sequence number in this transfer
   */
  uint32_t seqnum;
  ProtobufCBinaryData payload;
};
#define OTA_MESSAGE_TSFR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ota_message_tsfr__descriptor) \
    , {0,NULL}, {0,NULL}, 0, {0,NULL} }


struct  _OtaMessageTsfrAck
{
  ProtobufCMessage base;
  ProtobufCBinaryData deviceid;
  ProtobufCBinaryData ota_resp_hash;
};
#define OTA_MESSAGE_TSFR_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ota_message_tsfr_ack__descriptor) \
    , {0,NULL}, {0,NULL} }


struct  _OtaMessageTsfrQuery
{
  ProtobufCMessage base;
  ProtobufCBinaryData deviceid;
  ProtobufCBinaryData ota_resp_hash;
  uint32_t seqnum;
};
#define OTA_MESSAGE_TSFR_QUERY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ota_message_tsfr_query__descriptor) \
    , {0,NULL}, {0,NULL}, 0 }


/*
 * communications and security
 * udp / tcp with DTLS 1.0 or TLS 1.2 shall be used for connection establishment
 * when using tcp .. sequence number is ignored (tcp does reordering and retransmits)
 * the design is as follow
 * 1. client periodically polls for any new software update - poll interval is configured at client
 * client sends additional information about its hw, sw capabilities and the current version of software its running
 * in cases such as for example:
 * a. a vendor's older version of hardware still requires backwards compatibility and seceurity updates but may not
 *    contain major updates like x and y component updates
 * b. client may also send individual component status as a key val pair such as sofware name and version, so incase
 *    if there is an update for only particular software, that could be made available
 * 2. server sends out a response in the ota dialogue if update is available, and whats the version and along with it the
 *    filesize and encryption being used on the firmware while its being generated - client must have same AES keys as
 *    that of the server for successful decrypt
 * 3. once there is a software update, client may ask the server that it requesting a new update with an ack policy -
 *    both communications takes place over udp - the client must set its txbuf_size to a value that's deseriable at the
 *    client end, so that the server can sequentially divide the firmware into chunks with specific sequence numbers.
 *    this is very important, because if there is a mismatch, and added packet loss, the cause could be that client may
 *    not be receiving a proper packet with requested seqnum
 * 4. at every ack_policy repeat, the client pushes an ack so that server can know that client is "there" and not stopped
 *    or lost its network.
 *    there can be cases where the packet loss cause of above. in such cases client can simply send out missed sequence
 *    numbers to the server and it may respond back to the client with required data
 */
struct  _OtaMessage
{
  ProtobufCMessage base;
  OtaMessage__OtaProtoTypes type;
  /*
   * from device to the cloud
   */
  OtaMessagePoll *poll;
  /*
   * from cloud to the device
   */
  OtaMessagePollResp *poll_resp;
  /*
   * let server create a transfer connection to us
   */
  OtaMessageTsfrHook *tsfr_hook;
  OtaMessageTsfr *tsfr_msg;
  /*
   * require an ack for every 10 packets
   */
  OtaMessageTsfrAck *ack;
  OtaMessageTsfrQuery *query;
};
#define OTA_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&ota_message__descriptor) \
    , 0, NULL, NULL, NULL, NULL, NULL, NULL }


/* OtaKeyValdata methods */
void   ota_key_valdata__init
                     (OtaKeyValdata         *message);
size_t ota_key_valdata__get_packed_size
                     (const OtaKeyValdata   *message);
size_t ota_key_valdata__pack
                     (const OtaKeyValdata   *message,
                      uint8_t             *out);
size_t ota_key_valdata__pack_to_buffer
                     (const OtaKeyValdata   *message,
                      ProtobufCBuffer     *buffer);
OtaKeyValdata *
       ota_key_valdata__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ota_key_valdata__free_unpacked
                     (OtaKeyValdata *message,
                      ProtobufCAllocator *allocator);
/* OtaMessagePoll methods */
void   ota_message_poll__init
                     (OtaMessagePoll         *message);
size_t ota_message_poll__get_packed_size
                     (const OtaMessagePoll   *message);
size_t ota_message_poll__pack
                     (const OtaMessagePoll   *message,
                      uint8_t             *out);
size_t ota_message_poll__pack_to_buffer
                     (const OtaMessagePoll   *message,
                      ProtobufCBuffer     *buffer);
OtaMessagePoll *
       ota_message_poll__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ota_message_poll__free_unpacked
                     (OtaMessagePoll *message,
                      ProtobufCAllocator *allocator);
/* OtaMessagePollResp__OtaGmtime methods */
void   ota_message_poll_resp__ota_gmtime__init
                     (OtaMessagePollResp__OtaGmtime         *message);
/* OtaMessagePollResp methods */
void   ota_message_poll_resp__init
                     (OtaMessagePollResp         *message);
size_t ota_message_poll_resp__get_packed_size
                     (const OtaMessagePollResp   *message);
size_t ota_message_poll_resp__pack
                     (const OtaMessagePollResp   *message,
                      uint8_t             *out);
size_t ota_message_poll_resp__pack_to_buffer
                     (const OtaMessagePollResp   *message,
                      ProtobufCBuffer     *buffer);
OtaMessagePollResp *
       ota_message_poll_resp__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ota_message_poll_resp__free_unpacked
                     (OtaMessagePollResp *message,
                      ProtobufCAllocator *allocator);
/* OtaMessageTsfrHook methods */
void   ota_message_tsfr_hook__init
                     (OtaMessageTsfrHook         *message);
size_t ota_message_tsfr_hook__get_packed_size
                     (const OtaMessageTsfrHook   *message);
size_t ota_message_tsfr_hook__pack
                     (const OtaMessageTsfrHook   *message,
                      uint8_t             *out);
size_t ota_message_tsfr_hook__pack_to_buffer
                     (const OtaMessageTsfrHook   *message,
                      ProtobufCBuffer     *buffer);
OtaMessageTsfrHook *
       ota_message_tsfr_hook__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ota_message_tsfr_hook__free_unpacked
                     (OtaMessageTsfrHook *message,
                      ProtobufCAllocator *allocator);
/* OtaMessageTsfr methods */
void   ota_message_tsfr__init
                     (OtaMessageTsfr         *message);
size_t ota_message_tsfr__get_packed_size
                     (const OtaMessageTsfr   *message);
size_t ota_message_tsfr__pack
                     (const OtaMessageTsfr   *message,
                      uint8_t             *out);
size_t ota_message_tsfr__pack_to_buffer
                     (const OtaMessageTsfr   *message,
                      ProtobufCBuffer     *buffer);
OtaMessageTsfr *
       ota_message_tsfr__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ota_message_tsfr__free_unpacked
                     (OtaMessageTsfr *message,
                      ProtobufCAllocator *allocator);
/* OtaMessageTsfrAck methods */
void   ota_message_tsfr_ack__init
                     (OtaMessageTsfrAck         *message);
size_t ota_message_tsfr_ack__get_packed_size
                     (const OtaMessageTsfrAck   *message);
size_t ota_message_tsfr_ack__pack
                     (const OtaMessageTsfrAck   *message,
                      uint8_t             *out);
size_t ota_message_tsfr_ack__pack_to_buffer
                     (const OtaMessageTsfrAck   *message,
                      ProtobufCBuffer     *buffer);
OtaMessageTsfrAck *
       ota_message_tsfr_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ota_message_tsfr_ack__free_unpacked
                     (OtaMessageTsfrAck *message,
                      ProtobufCAllocator *allocator);
/* OtaMessageTsfrQuery methods */
void   ota_message_tsfr_query__init
                     (OtaMessageTsfrQuery         *message);
size_t ota_message_tsfr_query__get_packed_size
                     (const OtaMessageTsfrQuery   *message);
size_t ota_message_tsfr_query__pack
                     (const OtaMessageTsfrQuery   *message,
                      uint8_t             *out);
size_t ota_message_tsfr_query__pack_to_buffer
                     (const OtaMessageTsfrQuery   *message,
                      ProtobufCBuffer     *buffer);
OtaMessageTsfrQuery *
       ota_message_tsfr_query__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ota_message_tsfr_query__free_unpacked
                     (OtaMessageTsfrQuery *message,
                      ProtobufCAllocator *allocator);
/* OtaMessage methods */
void   ota_message__init
                     (OtaMessage         *message);
size_t ota_message__get_packed_size
                     (const OtaMessage   *message);
size_t ota_message__pack
                     (const OtaMessage   *message,
                      uint8_t             *out);
size_t ota_message__pack_to_buffer
                     (const OtaMessage   *message,
                      ProtobufCBuffer     *buffer);
OtaMessage *
       ota_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   ota_message__free_unpacked
                     (OtaMessage *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*OtaKeyValdata_Closure)
                 (const OtaKeyValdata *message,
                  void *closure_data);
typedef void (*OtaMessagePoll_Closure)
                 (const OtaMessagePoll *message,
                  void *closure_data);
typedef void (*OtaMessagePollResp__OtaGmtime_Closure)
                 (const OtaMessagePollResp__OtaGmtime *message,
                  void *closure_data);
typedef void (*OtaMessagePollResp_Closure)
                 (const OtaMessagePollResp *message,
                  void *closure_data);
typedef void (*OtaMessageTsfrHook_Closure)
                 (const OtaMessageTsfrHook *message,
                  void *closure_data);
typedef void (*OtaMessageTsfr_Closure)
                 (const OtaMessageTsfr *message,
                  void *closure_data);
typedef void (*OtaMessageTsfrAck_Closure)
                 (const OtaMessageTsfrAck *message,
                  void *closure_data);
typedef void (*OtaMessageTsfrQuery_Closure)
                 (const OtaMessageTsfrQuery *message,
                  void *closure_data);
typedef void (*OtaMessage_Closure)
                 (const OtaMessage *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor ota_key_valdata__descriptor;
extern const ProtobufCMessageDescriptor ota_message_poll__descriptor;
extern const ProtobufCMessageDescriptor ota_message_poll_resp__descriptor;
extern const ProtobufCMessageDescriptor ota_message_poll_resp__ota_gmtime__descriptor;
extern const ProtobufCEnumDescriptor    ota_message_poll_resp__ota_poll_status__descriptor;
extern const ProtobufCEnumDescriptor    ota_message_poll_resp__ota_enc_alg__descriptor;
extern const ProtobufCEnumDescriptor    ota_message_poll_resp__ota_sign_alg__descriptor;
extern const ProtobufCMessageDescriptor ota_message_tsfr_hook__descriptor;
extern const ProtobufCMessageDescriptor ota_message_tsfr__descriptor;
extern const ProtobufCMessageDescriptor ota_message_tsfr_ack__descriptor;
extern const ProtobufCMessageDescriptor ota_message_tsfr_query__descriptor;
extern const ProtobufCMessageDescriptor ota_message__descriptor;
extern const ProtobufCEnumDescriptor    ota_message__ota_proto_types__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_ota_5fcomm_2eproto__INCLUDED */
